Από το βιβλίο YDKJS Up and Going

-----------
ΜΕΡΙΚΑ ΒΑΣΙΚΑ

implicit vs explicit coercion
e.g Χρήση της χαλαρής ισότητας == in "99.99"==99.99. Η  JavaScript μετατρέπει το
αριστερό μέρος "99.99" σε αριθμό , δηλαδή 99.99. Ετσι η ισότητα μετατρέπεται σε
99.99 == 99.99, δηλαδή  true...implicit

Σε ορισμένες γλώσσες δηλώνεις μια variable (container) για να κρατήσει
συγκεκριμένο τύπο μιας αξίας όπως number ή string. Static typing ή  type
enforcement, θεωρείται γενικά πλεονέκτημα του προγραμματισμού γιατί προλαβαίνει
τις μη επιθυμητές  μετατροπές των αξιών (value conversion).
Άλλες γλώσσες δίνουν έμφαση στον τύπο των για τις αξίες (types for values)
αντί των μεταβλητών. O όρος Weak typing ή αλλιώςdynamic typing, επιτρέπει  σε
μια μεταβλητή να κρατά οποιαδήποτε αξία κάθεσ στιγμή. Αυτό θεωρείτε γενικά
πλεονέκτημα για την ευελιξία ενός προγράμματος, το να επιτρέπεις δηλαδή
μια μόνο μεταβλητή να αναπαριστά μια αξία ανεξάρτητα από τον τύπο της κάθε
χρονική στιγμή κατά τη διάρκεια του προγράμματος.
Η JavaScript χρησιμοποιεί την τελευταία προσέγγιση.

console.log( amount );              // 215.9784
console.log( amount.toFixed( 2 ) ); // "215.98"
toFixed(..) η λειτουργία αυτή μας επιτρέπει να καθορίσουμε τα δεκαδικά ψηφία
και μετατέπει σε string.

Από την έκδοση ES6 της JS υπάρχει ο όρος σταθερά:
const TAX_RATE = 0.08;

Τιμές (values) οι οποίες δεν είναι ήδη ενός ορισμένου αναμενόμενου τύπυ συχνά
εξαναγκάζονται (coerced) σε αυτόν. Η δήλωση if προϋποθέτει boolean, αλλά αν της
περάσεις κάτι που δεν είναι θα συμβεί αυτό το φαινόμενο (coercion).

Με την δήλωση break μπορούμε να σταματήσουμε ένα βρόγχο.

SCOPE ή lexical scope. Στην JS κάθε συνάρτηση έχει το δικό της πεδίο
εφαρμογής (scope) το οποίο στην ουσία είναι μια συλλογή μεταβλητών και κανόνων
για το πως αυτές οι μεταβλητές προσεγγίζονται με το όνομα τους. Μόνο κώδικας
εντός της συνάρτησης μπορεί να έχει πρόσβαση στις μεταβλητές (scoped variables)
αυτής της συνάρτησης.
Το όνομα μιας μεταβλητής πρέπει να είναι μοναδικό μέσα στο ίδιο scope, ενώ η
ίδια μεταβλητή μπορεί να υπάρχει σε διαφορετικά.

function one() {
    // this `a` only belongs to the `one()` function
    var a = 1;
    console.log( a );
}

function two() {
    // this `a` only belongs to the `two()` function
    var a = 2;
    console.log( a );
}

one();      // 1
two();      // 2

Επίσης ένα scope μπορεί να εμφωλευθεί εντός ενός άλλου, ενώ ο κώδικας του
εσωτερικού έχει πρόσβαση στις μεταβλητές και των δύο (εσωτερικου και εξωτερικού)

function outer() {
    var a = 1;

    function inner() {
        var b = 2;

        // we can access both `a` and `b` here
        console.log( a + b );   // 3
    }

    inner();

    // we can only access `a` here
    console.log( a );           // 1
}

outer();
--------------------------------------------------

Η JS  χρησιμοποιεί typed values όχι typed variables!!! Επίσης παρέχει ένα
χειριστή (operator) typeof ο οποίος μπορεί να εξετάσει μια αξία και να μας
πει σε ποιό τύπο ανήκει. Μόνο οι values έχουν τύπους στην JS,οι μεταβλητές είναι
απλά δοχεία αυτών των αξιών.

Οι τύποι οι οποίοι υπάρχουν (built-in types) είναι : string, number, boolean,
null και undefined, object και symbol.

παράδειγματα:
var a;   typeof a;    //undefined
a="hi Jack"  typeof a;    //string
a=39;        typeof a;    //number
a=true;      typeof a;    //boolean
a=null       typeof a;    //object....πρόκειται για bug το δεχόμαστε ως έχει
a=undefined; typeof a;    //undefined
a={i:"f"}    typeof a;    //object
και για symbol ---> typeof "abcd" επιστρέφει "string" όχι string.

Παρατήρηση: Η μεταβλητή a κρατά κάθε διαφορετικό τύπο της αξίας (type of value)
και παρά τα φαινόμενα typeof a δεν ζητά τον "τύπο του a", αλλά τον "τύπο της
αξίας που βρίσκεται τώρα στην a." Μόνο οι values έχουν τύπους στην JS,οι
μεταβλητές είναι απλά δοχεία αυτών των αξιών.
Επίσης μπορούμε να θέσουμε a=undefined; αντίστοιχα με το var a; το ίδιο
συμβαίνει και με μια συνάρτηση που δεν επιστρέφει αξία ή με τη χρήση του τελεστή
void (operator void)

ΑΝΤΙΚΕΙΜΕΝΑ - OBJECTS

Αναφέρονται σε μια συμπαγής αξία (combound value), όπου μπορείς να θέσεις
ιδιότητες (ονομάζονται τοποθεσίες) [properties-called locations] κάθε μια από
τις οποίες κρατά αξίες κάθε τύπου.
Για παράδειγμα
var obj={
       a:23,
       b:"hi Jack"
       c:false,
       d:undefined
};
Οι επιμέρους ιδιότητες απεικονίζονται με δύο τρόπους:
obj.a; //23 ή obj["a"]; //23

Συνήθως χρησιμοποιείται η σημειογαφία της τελείας. Η αγκύλη χρησιμοποιείται:
* όταν έχουμε το όνομα μιας ιδιότητας με ειδικούς χαρακτήρες όπως
  obj["hi jack!"] , τέτοιες ιδιότητες αναφέρονται συχνά ως κλειδιά(keys). Η
  σημειογραφία των αγκυλών [] απαιτεί μια μεταβλητή(παρακάτω) ή ένα string
  literal (το οποίο μπαίνει μέσα σε "..." ή '...').
* η σημειογραφία με τις αγκύλες είναι επίσης χρήσιμη όταν θέλεις να έχεις
  σε μια ιδιότητα/κλειδί αλλά το όνομα της είναι αποθηκευμένο σε μια άλλη
  μεταβλητή.πχ.

  var obj={
         a:"ji jack",
         b:23;
  };

  var b="a";

  obj[b];    //"hi jack"
  obj["b"];  //23

Υπάρχουν επίσης οι τύποι(value types) arrays και functions, πρόκειται βέβαια
στην ουσία για ειδικές περιπτώσεις του τύπου object.

ΠΙΝΑΚΕΣ - ARRAYS

Πρόκειται για ένα αντικείμενο το οποίο κρατά αξίες κάθε τύπου, όχι σε
ονοματιζόμενες ιδιότητες κλειδιά(όπως a, b, c ...παραπάνω), αλλά σε αριθμημένες
θέσεις (numerically indexed positions).
Παράδειγμα:
var arr=[
       23,
       "hi jack",
       false
];
arr[0];    //23
arr[1];    //"hi jack"
arr[2];    //false
arr.length; //3
typeof arr;   //object

Θα μπορούσαμε ενδεχομένως να χρησιμοποιήσουμε ένα αντικείμενο δίνοντας
αριθμημένες τιμές αλλά γενικά ο καλύτερος τρόπος χρήσης είναι να
χρησιμοποιούνται πίνακες για αριθμικά δεικτοδοτούμενες αξίες και αντικείμενα
για ονόματα ιδιότητες(named properties).

ΣΥΝΑΡΤΗΣΕΙΣ - FUNCTIONS

function go(){
   return 23;
}

go.card="ji jack";

typeof go;   //function
typeof go();  //number
typeof go.card; //string

Το typeof go; επιστρέφει συνάρτηση (σε αντίθεση με τον πίνακα). Παρόλα αυτά
πρόκειται για υποτύπο των αντικειμένων, μπορεί να έχει ιδιότητες και θα
χρησιμοποιούμε γενικά ιδιότητες αντικειμένων συναρτήσεων (function object
properties) σε λίγες περιπτώσεις.

ΕΝΣΩΜΑΤΩΜΕΝΟΙ ΜΕΘΟΔΟΙ ΤΥΠΟΙ - Built-In Type Methods

Οι ενσωματωμένοι τύποι και υποτύποι έχουν συμμπεριφορές που αναφέρονται ως
ιδιότητες και μεθόδους, αρκετά χρήσιμες.
Για παράδειγμα:

var c="hi jack";
var d=2.32452342;

c.length;         //7
c.toUpperCase();  //"HI JACK"
d.toFixed(3);     //2.324

Το πως γίνεται αυτή η κλήση της c.toUpperCase(); είναι κάτι σύνθετο. Ενδεικτικά
μπορούμε να πούμε ότι υπάρχουν κάποια βασικά αντικείμενα τα οποία περικαλύπτουν
(object wrapper form) και τα ονομάζουμε NATIVE. Αυτά γίνονται ζευγάρι με
τους αρχικούς (primitive) τύπους. Πρόκειται λοιπόν για το object wrapper, το
οποίο ορίζει την μέθοδο πάνω στο πρωτότυπο.
Όταν χρησιμοποιείς μια primitive value πχ "hi jack", ως αντικείμενο
συσχετίζοντας μια μέθοδο ή ιδιότητα όπως toUpperCase() η JS αυτόματα
εμφωλεύει ("boxes") την αξία αυτή στην αντίστοιχη της object wrapper. Πιο
συγκεκριμένα ένα string μπορεί να περιτυλιχθεί (wrapped) από ένα αντικείμενο
String (κεφαλαίο), ένα number από ένα αντικείμενο Number, ένα boolean από ένα
αντικείμενο Boolean...

ΣΥΓΚΡΙΣΗ ΑΞΙΩΝ (VALUES)
Εξαναγκασμός(coercion)
explicit---> var k="23";
             var g=Number(k);   //άρα το k είναι string και το g number
implicit---> var k="23"
             var g=k*2;     // εδώ το k εξαναγκάστικε να γίνει αριθμός ώστε
                            // να τελεσθεί η πράξη
Σημαντικό: όταν μια αξία η οποία δεν είναι boolean εξαναγκάζεται να γίνει, σε
κάποιες περιπτώσεις είναι false στις λοιπές είναι true.
Η λίστα με τις false τιμές είναι:
""(άδειο string), 0, -0, NaN(invalid Number), null, undefined, false
Προσοχή [], {} άδειος πίνακας ή αντικείμενο δεν είναι false.

ΙΣΟΤΗΤΑ
Βασική διαφορά της αυστηρής ισότητας === με την απλή ==, είναι ότι η πρώτη
απαιτεί ισότητα των αξιών αλλά δεν επιτρέπει τον εξαναγκασμό(coercion), όπως
η απλή ισότητα. Έτσι για δύο μεταβλητές var k="23", και g=23, η απλή ισότητα
δίνει true, ενώ η αυστηρή false.
Για περισσότερα ανάτρεξε στο βιβλίο.
Προσοχή!Ένας πίνακας εξαναγκάζεται σε string με τις τιμές του χωρισμένες με
κόμμα, ενώ δύο πίνακες με ίδια περιεχόμενα δεν είναι ίσοι.

ΑΝΙΣΟΤΗΤΑ
Στην ανισότητα δεν υπάρχει το φαινόμενο της αυστηρής(===/!==). Όταν συγκρίνου-
με string αυτό γίνεται λεξικογραφικά, ενώ όταν συγκρίνουμε αριθμούς με string
που μπορούν να γίνουν valid number ή σύγκριση προκύπτει μεταξύ αριθμών. Αν
δεν μπορούν να γίνουν συγκρίνουμε με NaN άρα σε κάθε σενάριο έχουμε false.
ΠΧ. var k=23;
    var g="go";

    k>g;    //false
    k<g;    //false
    k==g;   //false

ΜΕΤΑΒΛΗΤΕΣ- Μπορούν να αρχίζουν με μικρό ή κεφαλαίο, _ ή $. Όχι με αριθμό
            αλλά μπορούν να περιέχουν αριθμό. Υπάρχουν βέβαια κάποιες
            δεσμευμένες λέξεις...

ΤΑ ΠΕΔΙΑ ΤΗΣ ΛΕΙΤΟΥΡΓΙΑΣ - FUNCTION SCOPE

Με τη λέξη κλειδί var δηλώνεις μια μεταβλητή που θα ανήκει στο πεδίο εφαρμογής
της συγκεκριμένης συνάρτησης ή θα είναι για όλο το πρόγραμμα (global), εάν 
